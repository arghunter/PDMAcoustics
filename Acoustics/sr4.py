#!/usr/bin/env python3
import serial
import time
import argparse
import csv
import numpy as np
from datetime import datetime

def twos_complement_to_int(value, bits=24):
    """
    Convert a two's complement value to a signed integer.
    
    Args:
        value (int): The two's complement value as an unsigned integer
        bits (int): Number of bits in the two's complement representation
        
    Returns:
        int: The signed integer value
    """
    if (value & (1 << (bits - 1))) != 0:  # If sign bit is set
        value = value - (1 << bits)       # Compute negative value
    return value

def receive_uart_data_to_csv(port, baudrate=9600, timeout=1, output_file=None):
    """
    Receives data from the specified serial port, processes data into a 16x16 array 
    based on byte0 value, and writes data to a CSV file.
    
    Args:
        port (str): Serial port name (e.g., 'COM3' on Windows, '/dev/ttyUSB0' on Linux)
        baudrate (int): Baud rate (default: 9600)
        timeout (int): Serial timeout in seconds (default: 1)
        output_file (str): CSV file name (default: autogenerated based on timestamp)
        
    Returns:
        numpy.ndarray: 16x16xN array with all values organized by byte0
    """
    # Initialize a list of lists to store data for each point (16x16)
    # This will be a ragged array where each element is a list of values for that point
    pdata = [[[] for _ in range(16)] for _ in range(16)]
    
    # Counter for each byte0 value seen
    byte0_counters = np.zeros((16, 16), dtype=int)
    
    # Generate default output filename if not provided
    if output_file is None:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_file = f"uart_data_{timestamp}.csv"
    
    try:
        # Open the serial port
        ser = serial.Serial(port, baudrate, timeout=timeout)
        print(f"Connected to {port} at {baudrate} baud")
        print(f"Data will be saved to {output_file}")
        
        # Create and open CSV file
        with open(output_file, 'w', newline='') as csvfile:
            fieldnames = ['packet_num', 'byte0', 'row', 'col', 'occurrence', 
                         'byte1', 'byte2', 'byte3', 'raw_24bit_value', 'signed_value']
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            
            # Counter to track byte position
            byte_counter = 0
            word_counter = 0
            current_word = {}
            
            while True:
                # Read a byte from the serial port
                data = ser.read(1)
                
                if data:
                    # Convert byte to integer
                    byte_value = int.from_bytes(data, byteorder='big')
                    
                    # Determine which position in the 32-bit word
                    position = byte_counter % 4
                    
                    if position == 0:
                        # First byte - used to determine position in 16x16 array
                        pt = byte_value
                        row = int(pt / 16)
                        col = int(pt % 16)
                        
                        # Ensure pt is within valid range
                        if 0 <= pt < 256 and 0 <= row < 16 and 0 <= col < 16:
                            current_word = {
                                'packet_num': word_counter, 
                                'byte0': pt,
                                'row': row,
                                'col': col,
                                'occurrence': byte0_counters[row, col]
                            }
                            print(f"Byte0: {pt} (Position: [{row},{col}], Count: {byte0_counters[row, col]})")
                        else:
                            print(f"Warning: Invalid byte0 value {pt}, skipping this packet")
                            # Skip this packet by resetting position
                            byte_counter = 3  # Will become 0 after increment at end of loop
                    
                    elif position == 1:
                        # MSB of 24-bit value
                        current_word['byte1'] = byte_value
                        print(f"Byte 1 (MSB of 24-bit value): {byte_value}")
                    
                    elif position == 2:
                        current_word['byte2'] = byte_value
                        print(f"Byte 2: {byte_value}")
                    
                    elif position == 3:
                        # LSB of 24-bit value
                        current_word['byte3'] = byte_value
                        
                        # Calculate the 24-bit value (byte1 is MSB)
                        raw_24bit = (current_word['byte1'] << 16) | (current_word['byte2'] << 8) | byte_value
                        current_word['raw_24bit_value'] = f"0x{raw_24bit:06X}"
                        
                        # Convert to signed value using two's complement
                        signed_value = twos_complement_to_int(raw_24bit, 24)
                        current_word['signed_value'] = signed_value
                        
                        # Store in appropriate position in pdata
                        row = current_word['row']
                        col = current_word['col']
                        pdata[row][col].append(signed_value)
                        
                        # Write to CSV
                        writer.writerow(current_word)
                        csvfile.flush()  # Ensure data is written to disk
                        
                        print(f"Byte 3 (LSB): {byte_value}")
                        print(f"24-bit raw value: {current_word['raw_24bit_value']}")
                        print(f"Signed value: {signed_value}")
                        print(f"Stored at pdata[{row}][{col}][{byte0_counters[row, col]}]\n")
                        
                        # Increment counter for this position
                        byte0_counters[row, col] += 1
                        word_counter += 1
                    
                    # Increment byte counter
                    byte_counter += 1
                    
    except KeyboardInterrupt:
        print("\nReceiver stopped by user")
    except serial.SerialException as e:
        print(f"Error: {e}")
    finally:
        if 'ser' in locals() and ser.is_open:
            ser.close()
            print("Serial port closed")
        
        # Print summary
        print("\nReceived data summary:")
        print(f"Total packets received: {word_counter}")
        
        # Report how many values were received for each position
        print("\nValues received per position (row, col):")
        for row in range(16):
            for col in range(16):
                count = byte0_counters[row, col]
                if count > 0:
                    print(f"Position [{row},{col}] (byte0={row*16+col}): {count} values")
        
        print(f"\nData saved to {output_file}")
        
        # Create uniform-sized numpy array for return
        # Find the maximum number of values for any position
        max_values = max(max(len(pdata[row][col]) for col in range(16)) for row in range(16))
        if max_values == 0:
            max_values = 1  # Ensure at least one dimension for empty arrays
            
        # Create fixed-size numpy array filled with NaN
        uniform_pdata = np.full((16, 16, max_values), np.nan)
        
        # Fill the array with available values
        for row in range(16):
            for col in range(16):
                for i, value in enumerate(pdata[row][col]):
                    uniform_pdata[row, col, i] = value
        
        return uniform_pdata, pdata, byte0_counters

if __name__ == "__main__":

    

    
    uniform_pdata, raw_pdata, counters = receive_uart_data_to_csv("COM9", 921600, 1)
    
    # Visualization code if enabled
    if True:
        try:
            import matplotlib.pyplot as plt
            
            # Create a heatmap of the latest values
            latest_values = np.zeros((16, 16))
            for row in range(16):
                for col in range(16):
                    if len(raw_pdata[row][col]) > 0:
                        latest_values[row, col] = raw_pdata[row][col][-1]
            
            plt.figure(figsize=(10, 8))
            plt.imshow(latest_values, cmap='viridis')
            plt.colorbar(label='Value')
            plt.title('Latest 24-bit Values in 16x16 Grid')
            plt.xlabel('Column')
            plt.ylabel('Row')
            plt.savefig('heatmap.png')
            plt.show()
            
        except ImportError:
            print("Matplotlib not installed. Skipping visualization.")