#!/usr/bin/env python3
import serial
import time
import argparse
import serial
import time
import argparse
import csv
from datetime import datetime

def receive_uart_data_to_csv(port, baudrate=9600, timeout=1, output_file=None):
    """
    Receives data from the specified serial port, organizes bytes into arrays
    based on their position in 32-bit words, and writes the data to a CSV file.
    
    Args:
        port (str): Serial port name (e.g., 'COM3' on Windows, '/dev/ttyUSB0' on Linux)
        baudrate (int): Baud rate (default: 9600)
        timeout (int): Serial timeout in seconds (default: 1)
        output_file (str): CSV file name (default: autogenerated based on timestamp)
        
    Returns:
        tuple: Four arrays containing bytes from each position
    """
    # Initialize arrays for each byte position
    byte0_array = []  # Most significant byte (byte_index 0)
    byte1_array = []  # Second byte (byte_index 1)
    byte2_array = []  # Third byte (byte_index 2)
    byte3_array = []  # Least significant byte (byte_index 3)
    
    # Generate default output filename if not provided
    if output_file is None:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_file = f"uart_data_{timestamp}.csv"
    
    try:
        # Open the serial port
        ser = serial.Serial(port, baudrate, timeout=timeout)
        print(f"Connected to {port} at {baudrate} baud")
        print(f"Data will be saved to {output_file}")
        
        # Create and open CSV file
        with open(output_file, 'w', newline='') as csvfile:
            fieldnames = ['packet_num', 'byte0', 'byte1', 'byte2', 'byte3', 'full_word']
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            
            # Counter to track byte position
            byte_counter = 0
            word_counter = 0
            current_word = {}
            
            while True:
                # Read a byte from the serial port
                data = ser.read(1)
                
                if data:
                    # Convert byte to integer
                    byte_value = int.from_bytes(data, byteorder='big')
                    
                    # Determine which array to append to based on position
                    position = byte_counter % 4
                    
                    if position == 0:
                        byte0_array.append(byte_value)
                        current_word = {'packet_num': word_counter, 'byte0': byte_value}
                        print(f"Byte 0 (MSB): {byte_value}")
                    elif position == 1:
                        byte1_array.append(byte_value)
                        current_word['byte1'] = byte_value
                        print(f"Byte 1: {byte_value}")
                    elif position == 2:
                        byte2_array.append(byte_value)
                        current_word['byte2'] = byte_value
                        print(f"Byte 2: {byte_value}")
                    elif position == 3:
                        byte3_array.append(byte_value)
                        current_word['byte3'] = byte_value
                        
                        # Calculate the full 32-bit word
                        full_word = (current_word['byte0'] << 24) | (current_word['byte1'] << 16) | \
                                   (current_word['byte2'] << 8) | byte_value
                        current_word['full_word'] = f"0x{full_word:08X}"
                        
                        # Write the complete word to the CSV
                        writer.writerow(current_word)
                        csvfile.flush()  # Ensure data is written to disk
                        
                        print(f"Byte 3 (LSB): {byte_value}")
                        print(f"Complete word: {current_word['full_word']}\n")
                        
                        word_counter += 1
                    
                    # Increment byte counter
                    byte_counter += 1
                    
    except KeyboardInterrupt:
        print("\nReceiver stopped by user")
    except serial.SerialException as e:
        print(f"Error: {e}")
    finally:
        if 'ser' in locals() and ser.is_open:
            ser.close()
            print("Serial port closed")
        
        # Print summary
        print("\nReceived data summary:")
        print(f"Total packets received: {len(byte3_array)}")
        print(f"Data saved to {output_file}")
        
        return byte0_array, byte1_array, byte2_array, byte3_array


if __name__ == "__main__":

    

    
    receive_uart_data_to_csv("COM9", 921600, 1)